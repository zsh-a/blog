import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,a as l,b as r,f as a}from"./app-6f6f0afa.js";const o={},s=a('<ul><li><p>fault tolerance</p><ul><li>replicated servers</li></ul></li><li><p>consistency</p></li><li><p>performance</p><ul><li>Load imbalance</li><li>Slowest-of-N latency</li></ul></li></ul><h1 id="gfs" tabindex="-1"><a class="header-anchor" href="#gfs" aria-hidden="true">#</a> GFS</h1><ul><li>自动错误恢复</li><li>用于大文件顺序访问</li></ul><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h2><ul><li>coordinator：追踪文件名</li><li>chunkservers：存储64 MB chunks</li><li>每个chunk有3个副本</li></ul><h3 id="coordinator-state" tabindex="-1"><a class="header-anchor" href="#coordinator-state" aria-hidden="true">#</a> coordinator state</h3><ul><li>file name -&gt; <ul><li>array of chunk handles (nv)</li></ul></li><li>chunk handle -&gt; <ul><li>version (nv)</li><li>list of chunkservers (v)</li><li>primary (v)</li><li>lease time (v)</li></ul></li></ul><p>nv: state also written to disk</p><h1 id="raft" tabindex="-1"><a class="header-anchor" href="#raft" aria-hidden="true">#</a> Raft</h1><ul><li>一个容错系统依赖单一实体做出关键决策</li><li>实现容错和test-and-set服务 <ul><li>复制：可能存在网络分区，多个brain <ul><li>无法区分<strong>server crashed</strong>和<strong>network broken</strong></li></ul></li></ul></li></ul><h2 id="大多数投票" tabindex="-1"><a class="header-anchor" href="#大多数投票" aria-hidden="true">#</a> 大多数投票</h2>',11),d=l("li",null,"最多只有一个分区存在大多数，打破对称性",-1),n={class:"MathJax",jax:"SVG",style:{position:"relative"}},h={style:{"vertical-align":"-0.464ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.272ex",height:"2.059ex",role:"img",focusable:"false",viewBox:"0 -705 2772.4 910","aria-hidden":"true"},u=a('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(1272.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2272.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g>',1),c=[u],p=l("mjx-assistive-mml",{unselectable:"on",display:"inline"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("mn",null,"2"),l("mi",null,"f"),l("mo",null,"+"),l("mn",null,"1")])],-1),m={class:"MathJax",jax:"SVG",style:{position:"relative"}},g={style:{"vertical-align":"-0.464ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.244ex",height:"2.059ex",role:"img",focusable:"false",viewBox:"0 -705 550 910","aria-hidden":"true"},Q=l("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[l("g",{"data-mml-node":"math"},[l("g",{"data-mml-node":"mi"},[l("path",{"data-c":"1D453",d:"M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"})])])],-1),T=[Q],f=l("mjx-assistive-mml",{unselectable:"on",display:"inline"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("mi",null,"f")])],-1),x=a('<h2 id="流程" tabindex="-1"><a class="header-anchor" href="#流程" aria-hidden="true">#</a> 流程</h2><ol><li>client 发送command到leader</li><li>leader 向log添加command</li><li>leader 向followers发送AppendEntries RPCs</li><li>followers向log添加command</li><li>leader等待直到大多数回复<strong>committed</strong></li><li>leader 执行该命令，回复client</li><li>leader在下一次AppendEntries中捎带commit信息</li><li>当leader commit时，followers执行Entry</li></ol><h3 id="leader选举" tabindex="-1"><a class="header-anchor" href="#leader选举" aria-hidden="true">#</a> leader选举</h3><ul><li><p>确保所有副本执行相同命令，相同顺序</p></li><li><p>为leader确定顺序，new leader -&gt; new term</p><ul><li>一个term最多一个leader，可能没有leader</li></ul></li><li><p>leader选举时机</p><ul><li>当没有收到<strong>election timeout</strong>消息时，增加<code>currentTerm</code>，尝试收集投票 <ul><li>可能导致无用选举</li></ul></li></ul></li><li><p>如何确保一个term中只有一个leader?</p><ul><li>leader必须获得大多数票</li><li>每个server在一个term仅会投一票 <ul><li>若自己为候选人，则投给自己</li><li>否则，投给第一个要求选票者</li></ul></li><li>只有一个server能够获得大多数票</li></ul></li><li><p>server如何知道最新选举的leader?</p><ul><li>leader 发送有最大term 的<strong>AppendEntries</strong>心跳消息</li><li>如果收到<strong>AppendEntries</strong>，则知道最新的leader</li><li>心跳消息会抑制新的选举启动 <ul><li>必须小于leader选举timeout</li></ul></li></ul></li><li><p>可能出现选票分散情况，leader选举一致失败</p><ul><li>为选举timeout增加随机性</li><li><strong>随机性打破对称性</strong></li><li>随机性延迟在网络协议中经常出现</li></ul></li><li><p>如何选择选举timeout?</p><ul><li>至少几个心跳间隔，避免不需要的选举</li><li>随机部分足够长，确保有一个能成功</li><li>足够短，确保快速响应</li></ul></li><li><p>如果旧的leader没有意识到新的leader?</p><ul><li>可能旧leader没有收到选举消息</li><li>可能不在大多数分区内</li><li>旧leader将会收到更新的term 在AppendEntries中并下台，或者不能得到大多数回复，所以不会commit或执行新的log</li><li>少数部分可能收到旧leader的AppendEntries，可能导致log分叉</li></ul></li></ul><h3 id="log" tabindex="-1"><a class="header-anchor" href="#log" aria-hidden="true">#</a> log</h3><ul><li><p>leader选举后client仅与leader交互</p></li><li><p>一个leader失败后可能的异常情况</p><ul><li>不一致副本</li><li>丢失操作</li><li>重复操作</li></ul></li><li><p>一个log entry仅能执行同一个command</p></li><li><p>强制followers与新leader的log保持一致</p><ul><li>每个followers删除log尾部与leader不一致的部分</li></ul></li><li><p>确保选择的leader具有所有已提交的log</p><ul><li>RequestVote handler 仅将票投给最新的log <ul><li>在最后的log entry 有更大的term</li><li>相同的last term 并且相同或更长的log</li></ul></li></ul></li></ul><h3 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化" aria-hidden="true">#</a> 持久化</h3><ul><li><p>修复策略</p><ul><li>使用一个新server替换 <ul><li>传输所有log</li></ul></li><li>重启crashed server <ul><li>恢复持久化的状态</li></ul></li></ul></li><li><p>持久化状态</p><ul><li><code>log[]</code><ul><li>确保committed log 保持一致</li></ul></li><li><code>votedFor</code><ul><li>避免投出多票</li></ul></li><li><code>currentTerm</code></li></ul></li><li><p>优化磁盘写入</p><ul><li>batch</li><li>battery-backed RAM</li><li>lazy</li></ul></li><li><p>crash+reboot 恢复</p><ul><li>redo 整个log <ul><li>速度慢</li></ul></li><li>使用snapshot，redo snapshot 之后的log</li></ul></li></ul><h3 id="log-压缩-和-snapshots" tabindex="-1"><a class="header-anchor" href="#log-压缩-和-snapshots" aria-hidden="true">#</a> log 压缩 和 Snapshots</h3><ul><li><p>不能丢弃的log</p><ul><li>committed 但未执行</li><li>不清楚是否committed</li></ul></li><li><p>周期性创建<strong>snapshot</strong></p><ul><li>持久化raft状态和snapshot</li><li>丢弃snapshot之前的log</li></ul></li><li><p>如果follower的log处于leader的log之前</p><ul><li>follower离线一段时间，leader已经丢弃之前的log</li><li><code>InstallSnapshot</code> RPC，设置状态</li></ul></li><li><p>对于big DB，</p></li><li><p>数据以B-Tree存储在disk中</p><ul><li>无需显式Snapshot，因为数据已经存在</li></ul></li></ul><h3 id="linearizability" tabindex="-1"><a class="header-anchor" href="#linearizability" aria-hidden="true">#</a> linearizability</h3><ul><li>强一致性，与单个server行为一致</li><li>所有操作存在一个全序关系匹配实际时间，并且每个读操作都会最新写入的值</li><li>而顺序一致性仅要求本地的顺序性，偏序关系</li></ul><h3 id="重复rpc检测" tabindex="-1"><a class="header-anchor" href="#重复rpc检测" aria-hidden="true">#</a> 重复RPC检测</h3><ul><li><p>如果RPC超时</p><ul><li>server is dead or request was dropped：re-send</li><li>server executed, but reply was lost: re-send is dangerous</li></ul></li><li><p>使用k/v维护已执行的RPC</p></li></ul><h3 id="只读操作" tabindex="-1"><a class="header-anchor" href="#只读操作" aria-hidden="true">#</a> 只读操作</h3><ul><li><p>Raft必须commit只读操作log，因为可能出现split brain</p></li><li><p>减少只读操作commit</p><ul><li>leases，设置时间限制</li><li>当leader每次得到<strong>AppendEntries</strong>大多数时，可以设置一段时间不需要将只读操作加入log</li><li>a new leader不能执行put操作知道lease过期</li><li>followers 记录最后一次响应AppendEntries的时间，并将其告诉new leader</li></ul></li></ul><h1 id="cache一致性" tabindex="-1"><a class="header-anchor" href="#cache一致性" aria-hidden="true">#</a> cache一致性</h1><h2 id="一致性协议" tabindex="-1"><a class="header-anchor" href="#一致性协议" aria-hidden="true">#</a> 一致性协议</h2><ul><li>共享一个lock server(LS)，每个文件一把锁</li><li>cache数据仅当持有锁时</li><li>acquire lock -&gt; read from shared storage</li><li>write to shared storage -&gt; release lock</li></ul><h2 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性" aria-hidden="true">#</a> 原子性</h2><ul><li>对于相应的系统调用（create file, remove file, rename, &amp;c），获取所有操作数据的锁</li><li>当所有操作完成时释放锁</li></ul><h2 id="崩溃恢复" tabindex="-1"><a class="header-anchor" href="#崩溃恢复" aria-hidden="true">#</a> 崩溃恢复</h2><ul><li><p>write-ahead logging</p></li><li><p>每个worker在shared storage中有自己的log file</p></li><li><p>当节点持有锁时发生崩溃</p><ul><li>LS 发送revoke，无响应</li><li>LS超时，告知节点从log中恢复 <ul><li>读取log</li><li>执行log中操作</li><li>告知LS完成，LS release节点持有的锁</li></ul></li></ul></li><li><p>Paxos or Raft 复制 LS</p></li></ul><h1 id="spanner-分布式事务" tabindex="-1"><a class="header-anchor" href="#spanner-分布式事务" aria-hidden="true">#</a> Spanner：分布式事务</h1><ul><li>paxos之上的两阶段提交</li><li>同步时间：只读事务</li></ul>',25);function w(_,b){return e(),i("div",null,[s,l("ul",null,[d,l("li",null,[l("mjx-container",n,[(e(),i("svg",h,c)),p]),r("个服务器能容忍"),l("mjx-container",m,[(e(),i("svg",g,T)),f]),r("个服务器失败")])]),x])}const L=t(o,[["render",w],["__file","distributed system.html.vue"]]);export{L as default};
