import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as l,a,b as i,f as n}from"./app-6f6f0afa.js";const t="/blog/image/os/link list delete.png",o="/blog/image/os/live_lock.png",p="/blog/image/os/modified.png",c="/blog/image/os/shared.png",r="/blog/image/os/invalid.png",u="/blog/image/os/cache.png",d="/blog/image/os/mcs.png",h="/blog/image/os/numa.png",k="/blog/image/os/ntfs.png",g="/blog/image/os/filesystem.png",m="/blog/image/os/clone.png",v="/blog/image/os/fuse.png",b="/blog/image/os/trap.png",T="/blog/image/os/vis1.png",f="/blog/image/os/vis11.png",x="/blog/image/os/trap1.png",Q="/blog/image/os/trap2.png",M="/blog/image/os/trap41.png",_="/blog/image/os/armvirtual.png",V="/blog/image/os/kvm.png",y="/blog/image/os/kvmio.png",w="/blog/image/os/step2.png",C="/blog/image/os/netemu1.png",A="/blog/image/os/netemu2.png",P="/blog/image/os/netemu3.png",S="/blog/image/os/netemu4.png",I="/blog/image/os/iommu.png",E="/blog/image/os/iommu2.png",H="/blog/image/os/int.png",L="/blog/image/os/linuxnet.png",R="/blog/image/os/remotedebug.png",U={},B=n(`<h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h1><h2 id="分页虚拟内存" tabindex="-1"><a class="header-anchor" href="#分页虚拟内存" aria-hidden="true">#</a> 分页虚拟内存</h2><h3 id="tlb刷新" tabindex="-1"><a class="header-anchor" href="#tlb刷新" aria-hidden="true">#</a> TLB刷新</h3><ul><li><p>AARCH64内核和应用程序使用不同页表</p><ul><li>页表地址分别存放在TTBR0_EL1和TTBR1_EL1</li><li>系统调用无需切换页表</li></ul></li><li><p>x86_64唯一页表基址存放在CR3</p><ul><li>将内核映射到高地址</li><li>避免系统调用TLB刷新开销</li></ul></li></ul><h3 id="如何降低tlb刷新开销" tabindex="-1"><a class="header-anchor" href="#如何降低tlb刷新开销" aria-hidden="true">#</a> 如何降低TLB刷新开销</h3><ul><li><p><strong>为不同的页表打上标签</strong></p><ul><li>TLB缓存项都有标签，切换页表不需要刷新TLB</li></ul></li><li><p><strong>x86_64:PCID</strong></p><ul><li>PCID存储在CR3的低12位</li></ul></li><li><p><strong>AARCH64:ASID</strong></p><ul><li>OS为不同进程分配8/16位ASID,将ASID存在TTBR0_EL1的高8/16位</li></ul></li></ul><h3 id="tlb与多核" tabindex="-1"><a class="header-anchor" href="#tlb与多核" aria-hidden="true">#</a> TLB与多核</h3><ul><li>需要刷新其他核的TLB吗？ <ul><li>一个进程可能在多个核上运行</li></ul></li><li>如何知道需要刷新哪些核心? <ul><li>通过系统的调度信息</li></ul></li><li>怎么刷新其他核? <ul><li>x86_64 ：发送IPI中断某个核，通知他主动刷新</li><li>AARCH64 : 可在local CPU上刷新其他核TLB</li></ul></li></ul><h1 id="进程与线程" tabindex="-1"><a class="header-anchor" href="#进程与线程" aria-hidden="true">#</a> 进程与线程</h1><h2 id="纤程" tabindex="-1"><a class="header-anchor" href="#纤程" aria-hidden="true">#</a> 纤程</h2><h3 id="linux纤程支持-ucontext" tabindex="-1"><a class="header-anchor" href="#linux纤程支持-ucontext" aria-hidden="true">#</a> Linux纤程支持 : ucontext</h3><ul><li><code>makecontext</code> 创建新ucontext</li><li><code>setcontext</code> 纤程切换</li><li><code>getcontext</code> 保存当前ucontext</li></ul><h1 id="ipc" tabindex="-1"><a class="header-anchor" href="#ipc" aria-hidden="true">#</a> IPC</h1><h2 id="共享内存" tabindex="-1"><a class="header-anchor" href="#共享内存" aria-hidden="true">#</a> 共享内存</h2><ul><li>操作系统为两个进程映射共同的内存区域</li><li>需要轮询是否有数据到达，导致资源浪费</li></ul><h2 id="消息传递" tabindex="-1"><a class="header-anchor" href="#消息传递" aria-hidden="true">#</a> 消息传递</h2><ul><li>通过内核消息传递机制发送和接收消息</li><li><code>Send(message)</code> <code>Recv(message)</code> 会阻塞进程，不会浪费资源</li><li><code>Send</code> 可以非阻塞，增大通信带宽，引入超时机制防止资源浪费</li></ul><h1 id="同步" tabindex="-1"><a class="header-anchor" href="#同步" aria-hidden="true">#</a> 同步</h1><h2 id="解决临界区问题的三个要求" tabindex="-1"><a class="header-anchor" href="#解决临界区问题的三个要求" aria-hidden="true">#</a> 解决临界区问题的三个要求</h2><ul><li><strong>互斥访问</strong>：同一时刻仅有一个进程可以进入临界区</li><li><strong>有限等待</strong>：当一个进程在申请进入临界区后，必须在有限的时间获得许可进入临界区，不能无限等待</li><li><strong>空闲让进</strong>：当没有进程在临界区中时，必须在请求进入临界区的进程中选择一个进入临界区，保证程序正常推进</li></ul><h2 id="互斥访问实现" tabindex="-1"><a class="header-anchor" href="#互斥访问实现" aria-hidden="true">#</a> 互斥访问实现</h2><ul><li><strong>关中断</strong>：保证执行过程不被打断. <em>仅适用于单核</em></li></ul><h3 id="compare-and-swap-cas" tabindex="-1"><a class="header-anchor" href="#compare-and-swap-cas" aria-hidden="true">#</a> Compare And Swap(CAS)</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">CAS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> addr<span class="token punctuation">,</span><span class="token keyword">int</span> expected<span class="token punctuation">,</span><span class="token keyword">int</span> new_value<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>addr<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>addr <span class="token operator">==</span> expected<span class="token punctuation">)</span>
        <span class="token operator">*</span>addr <span class="token operator">=</span> new_value<span class="token punctuation">;</span>
    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CAS为硬件原子操作：</p><ul><li>Intel锁总线实现</li><li>ARM：采用Load Link, Store Condition<div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>retry: 
  ldxr x0,addr #ll
  cmp x0,expected
  bne out
  stxr x1,new_value,addr #sc
  cbnx x1,retry
out:
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>修改时看addr是否被修改过，若修改过则重试</li></ul><h3 id="锁实现" tabindex="-1"><a class="header-anchor" href="#锁实现" aria-hidden="true">#</a> 锁实现</h3><h4 id="自旋锁-spinlock" tabindex="-1"><a class="header-anchor" href="#自旋锁-spinlock" aria-hidden="true">#</a> 自旋锁(Spinlock)</h4><p>lock操作</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">atomic_CAS</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>unlock</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>可能出现饥饿现象</li></ul><h4 id="排号锁-ticket-lock" tabindex="-1"><a class="header-anchor" href="#排号锁-ticket-lock" aria-hidden="true">#</a> 排号锁(Ticket Lock)</h4><ul><li>保证竞争者的公平性</li><li>根据竞争者到达的先后顺序传递锁</li></ul><p><strong>lock操作</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 拿号</span>
my_ticket <span class="token operator">=</span> <span class="token function">atomic_FAA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fetch and add </span>

<span class="token comment">// 等号</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>owner <span class="token operator">!=</span> my_ticket<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>unlock操作</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>lock<span class="token operator">-&gt;</span>owner<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="读写锁" tabindex="-1"><a class="header-anchor" href="#读写锁" aria-hidden="true">#</a> 读写锁</h4><ul><li>多个读者不互斥</li><li>读者与写者互斥</li></ul><h5 id="读者优先" tabindex="-1"><a class="header-anchor" href="#读者优先" aria-hidden="true">#</a> 读者优先</h5><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">rw_lock</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> reader<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">lock</span> reader_lock<span class="token punctuation">;</span> <span class="token comment">// 锁住reader变量</span>
    <span class="token keyword">struct</span> <span class="token class-name">lock</span> writer_lock<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">lock_reader</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rw_lock</span><span class="token operator">*</span> lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>reader_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    lock<span class="token operator">-&gt;</span>reader<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>reader <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>writer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>reader_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">unlock_reader</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rw_lock</span><span class="token operator">*</span> lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>reader_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    lock<span class="token operator">-&gt;</span>reader<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>reader <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>writer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>reader_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">lock_writer</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rw_lock</span><span class="token operator">*</span> lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>writer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">unlock_writer</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rw_lock</span><span class="token operator">*</span> lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>writer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>需要一个reader_lock保护reader变量，如何提高读者性能</li></ul><p><strong>Read Copy Update(RCU)</strong></p><ul><li>减少读者进入临界区的操作，提高读者效率</li></ul><p>硬件原子操作</p><ol><li>最大128bit</li><li>锁总线，性能瓶颈</li></ol><p>链表删除节点<br><img src="`+t+'" alt="" loading="lazy"></p><p><strong>局限</strong></p><ul><li>需要将源数据复制一份，导致内存消耗</li><li>删除后的节点不能立即删除，因为可能有读者正在读</li></ul><p><strong>RCU宽限期</strong></p><ul><li>需要知道进入临界区和离开临界区的时间</li><li>当最后一个访问旧值的读者离开临界区后释放内存</li></ul><h3 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h3><p><strong>原因</strong></p><ul><li>互斥访问</li><li>持有并等待</li><li>资源非抢占</li><li>循环等待</li></ul><h4 id="检测死锁与回复" tabindex="-1"><a class="header-anchor" href="#检测死锁与回复" aria-hidden="true">#</a> 检测死锁与回复</h4><p>找到资源分配图中的环</p><ul><li>kill所有进程</li><li>kill一个进程</li><li>全部回滚到前面状态</li></ul><h4 id="死锁预防" tabindex="-1"><a class="header-anchor" href="#死锁预防" aria-hidden="true">#</a> 死锁预防</h4><ol><li><p>避免互斥访问：通过其他手段（ie:代理执行）</p></li><li><p>不允许持有并等待：一次申请所有资源</p><ul><li>可能带来活锁(live lock)</li><li><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li><p>资源允许抢占：需要考虑如何恢复（取决于场景）</p></li><li><p>打破循环等待</p></li></ol><h4 id="死锁避免" tabindex="-1"><a class="header-anchor" href="#死锁避免" aria-hidden="true">#</a> 死锁避免</h4><p>银行家算法</p><h2 id="多核与并行" tabindex="-1"><a class="header-anchor" href="#多核与并行" aria-hidden="true">#</a> 多核与并行</h2><p><strong>并行加速比（理论上限）</strong><br> Amdahl&#39;s Law</p>',65),N={class:"MathJax",jax:"SVG",display:"true",style:{position:"relative"}},G={style:{"vertical-align":"-2.172ex"},xmlns:"http://www.w3.org/2000/svg",width:"17.965ex",height:"5.208ex",role:"img",focusable:"false",viewBox:"0 -1342 7940.4 2302","aria-hidden":"true"},D=n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(746.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(1802.6,0)"><g data-mml-node="mn" transform="translate(2818.9,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1111.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(2111.4,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(2614.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(3225.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4225.9,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4728.9,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(5228.9,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g><rect width="5897.9" height="60" x="120" y="220"></rect></g></g></g>',1),z=[D],O=a("mjx-assistive-mml",{unselectable:"on",display:"block"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[a("mi",null,"s"),a("mo",null,"="),a("mfrac",null,[a("mn",null,"1"),a("mrow",null,[a("mo",{stretchy:"false"},"("),a("mn",null,"1"),a("mo",null,"−"),a("mi",null,"p"),a("mo",{stretchy:"false"},")"),a("mo",null,"+"),a("mi",null,"p"),a("mrow",{"data-mjx-texclass":"ORD"},[a("mo",null,"/")]),a("mi",null,"s")])])])],-1),Z={class:"MathJax",jax:"SVG",style:{position:"relative"}},F={style:{"vertical-align":"-0.439ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.395ex",height:"1.439ex",role:"img",focusable:"false",viewBox:"0 -442 1058.8 636","aria-hidden":"true"},K=n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(780.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g></g></g>',1),j=[K],q=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mi",null,"p"),a("mo",null,":")])],-1),W=a("br",null,null,-1),X={class:"MathJax",jax:"SVG",style:{position:"relative"}},J={style:{"vertical-align":"-0.023ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.319ex",height:"1.023ex",role:"img",focusable:"false",viewBox:"0 -442 1024.8 452","aria-hidden":"true"},Y=n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(746.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g></g></g>',1),$=[Y],aa=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mi",null,"s"),a("mo",null,":")])],-1),na=n('<p>多核访问共享数据导致性能断崖</p><h3 id="缓存一致性" tabindex="-1"><a class="header-anchor" href="#缓存一致性" aria-hidden="true">#</a> 缓存一致性</h3><h4 id="msi状态" tabindex="-1"><a class="header-anchor" href="#msi状态" aria-hidden="true">#</a> MSI状态</h4><p><img src="'+p+'" alt="" loading="lazy"><br><img src="'+c+'" alt="" loading="lazy"><br><img src="'+r+'" alt="" loading="lazy"></p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>多cpu对单一缓存行竞争导致性能下降</p><p><strong>MCS lock</strong></p><ul><li>避免多核对于单一缓存行的竞争<br><img src="'+d+`" alt="" loading="lazy"></li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">mcs_node</span><span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token keyword">struct</span> <span class="token class-name">mcs_node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> flag<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">mcs_lock</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mcs_node</span><span class="token operator">*</span> tail<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
__thread <span class="token keyword">struct</span> <span class="token class-name">mcs_node</span> my_node<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mcs_lock</span><span class="token operator">*</span> lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mcs_node</span><span class="token operator">*</span> me <span class="token operator">=</span> <span class="token operator">&amp;</span>my_node<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mcs_node</span><span class="token operator">*</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    me<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    me<span class="token operator">-&gt;</span>flag <span class="token operator">=</span> WATTING<span class="token punctuation">;</span>
    tail <span class="token operator">=</span> <span class="token function">atomic_XCHG</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>tail<span class="token punctuation">,</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> me<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>me<span class="token operator">-&gt;</span>flag <span class="token operator">!=</span> GRANTED<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        me<span class="token operator">-&gt;</span>flag <span class="token operator">=</span> GRANTED<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mcs_lock</span><span class="token operator">*</span> lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mcs_node</span><span class="token operator">*</span> me <span class="token operator">=</span> <span class="token operator">&amp;</span>my_node<span class="token punctuation">;</span>
    <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>me<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">atomic_CAS</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>tail<span class="token punctuation">,</span>me<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> me<span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>me<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    me<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>flag <span class="token operator">=</span> GRANTED<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>unlock操作仅写一个私缓存行，不存在高度竞争的全局缓存行</li></ul><p>在非一致内存访问(NUMA)下，在临界区访问多cache行导致性能下降</p><figure><img src="`+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>跨节点的缓存一致性协议开销巨大(cpu需要访问其他节点的cache取回数据)</li></ul><p><strong>NUMA-aware设计：cohort</strong></p><ul><li>先获取每节点的本地锁，在获取全局锁</li><li>成功获取全局锁，释放时将其传递给<strong>本地等待队列</strong>的下一位</li><li>全局锁在一段时间内只在一个节点内部传递</li></ul><h3 id="内存模型" tabindex="-1"><a class="header-anchor" href="#内存模型" aria-hidden="true">#</a> 内存模型</h3><h4 id="严格一致性模型-strict-consistency" tabindex="-1"><a class="header-anchor" href="#严格一致性模型-strict-consistency" aria-hidden="true">#</a> 严格一致性模型(Strict Consistency)</h4><ul><li>对任意地址的读操作都能读到这个地址最近一次写的数据</li><li>访存操作顺序与全局时钟顺序一致</li><li>有唯一的执行结果</li></ul><h4 id="顺序一致性-sequential-consistency" tabindex="-1"><a class="header-anchor" href="#顺序一致性-sequential-consistency" aria-hidden="true">#</a> 顺序一致性(Sequential Consistency)</h4><ul><li>不要求操作按照真实的时间顺序全局可见</li><li>执行结果必须与一个全局的顺序一致</li><li>在调度下具有多种结果</li></ul><h4 id="tso-total-store-ordering" tabindex="-1"><a class="header-anchor" href="#tso-total-store-ordering" aria-hidden="true">#</a> TSO(Total Store Ordering)</h4><ul><li><p>对不同地址<strong>RR</strong>,<strong>RW</strong>,<strong>WW</strong>顺序可以保证</p></li><li><p><strong>WR</strong>的顺序不能保证</p></li><li><p>CPU存在乱序执行<br> CPU写cache后需要执行缓存一致性算法，为了提升性能，在CPU与cache之间增加一个<strong>Load/Store Buffer</strong>,CPU写数据首先写入<strong>Buffer</strong>,之后将数据批量写入cache，减少缓存一致性算法执行次数。但是导致了写延时，所以导致<strong>WR</strong>的顺序不能保证</p></li></ul><h4 id="弱一致性模型" tabindex="-1"><a class="header-anchor" href="#弱一致性模型" aria-hidden="true">#</a> 弱一致性模型</h4><ul><li>不保证任何对不同地址的读写操作顺序<br> ARM采用弱一致性模型，为了保证读写顺序，ARM提供了<code>barrier()</code>保证执行顺序。在<code>lock</code>时需要加<code>barrier</code></li></ul><h1 id="文件与存储" tabindex="-1"><a class="header-anchor" href="#文件与存储" aria-hidden="true">#</a> 文件与存储</h1><h2 id="基于inode的文件系统" tabindex="-1"><a class="header-anchor" href="#基于inode的文件系统" aria-hidden="true">#</a> 基于inode的文件系统</h2><ul><li>字符/块设备文件 <ul><li>记录设备的Major(表示设备类型)和minor(表示设备编号)号</li><li>可以作为系统调用参数</li></ul></li><li>FIFO文件 <ul><li>命名管道，用于进程通信</li><li>提供一个标识符，对该文件操作都在内存中，实现了<code>read()</code>,<code>write()</code>等接口</li></ul></li><li>SOCK文件 <ul><li>UNIX域套接字，用于进程间通信</li><li>通过<strong>socket</strong>API创建，当进程位于不同机器上时，仅需要修改少部分代码</li></ul></li></ul><p>这些方式复用了文件API，通过文件API实现不同的功能.</p><blockquote><p>everything is a file.</p></blockquote><h2 id="基于table的文件系统" tabindex="-1"><a class="header-anchor" href="#基于table的文件系统" aria-hidden="true">#</a> 基于Table的文件系统</h2><h3 id="ntfs" tabindex="-1"><a class="header-anchor" href="#ntfs" aria-hidden="true">#</a> NTFS</h3><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>每个文件在MFT中保留一项，记录了文件的元数据</li><li>查询文件仅需变量MFT，查询速度快 eg:everything</li><li>文件较小时可以内嵌在MFT中</li></ul><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>使用COW实现快照功能 <ul><li>将inode复制一份作为快照</li><li>标记数据块为COW</li></ul></li></ul><h3 id="fuse" tabindex="-1"><a class="header-anchor" href="#fuse" aria-hidden="true">#</a> FUSE</h3><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>在用户态实现文件系统，eg：将百度网盘映射到文件系统</li></ul><h2 id="崩溃一致性" tabindex="-1"><a class="header-anchor" href="#崩溃一致性" aria-hidden="true">#</a> 崩溃一致性</h2><h3 id="各种数据结构之间存在依赖关系与一致性要求" tabindex="-1"><a class="header-anchor" href="#各种数据结构之间存在依赖关系与一致性要求" aria-hidden="true">#</a> 各种数据结构之间存在依赖关系与一致性要求</h3><ul><li>inode中保存的文件大小，应该与其索引中保存的数据块个数相匹配- inode中保存的链接数，应与指向其的目录项个数相同</li><li>超级块中保存的文件系统大小，应该与文件系统所管理的空间大小相同</li><li>所有inode分配表中标记为空闲的inode均未被使用;标记为已用的inode均可以通过文件系统操作访问</li></ul><p><strong>系统崩溃情况下这些数据可能不一致</strong></p><h3 id="日志" tabindex="-1"><a class="header-anchor" href="#日志" aria-hidden="true">#</a> 日志</h3><ul><li>在文件操作之前，先将操作记录在日志中</li><li>所有操作记录完毕后，提交日志</li><li>再对文件进行操作</li></ul><p><strong>问题</strong></p><ul><li>每个操作都要写硬盘，内存缓存机制无意义</li><li>每个修改需要拷贝新数据到日志</li><li>相同块的修改被记录多次</li></ul><p><strong>解决方案</strong></p><ul><li>利用内存的页缓存：将日志保存在内存中，文件操作之前将日志写入磁盘</li><li>批量处理日志减少磁盘读写：将多个文件操作合并，每个修改的块仅需记录一次</li></ul><p><strong>日志提交</strong></p><ul><li><p>定时触发</p><ul><li>每一段时间触发一次</li><li>日志达到一定数量触发一次</li></ul></li><li><p>用户触发</p><ul><li>应用程序调用<code>fsync()</code></li></ul></li></ul><h1 id="系统虚拟化" tabindex="-1"><a class="header-anchor" href="#系统虚拟化" aria-hidden="true">#</a> 系统虚拟化</h1><ul><li><p>操作系统的接口层次</p><ul><li>ISA层 <ul><li>用户ISA：用户态可执行 eg:<code>mov, add</code></li><li>系统ISA：特权态可执行 eg:<code>msr</code></li></ul></li><li>ABI <ul><li>提供操作系统服务或硬件功能</li><li>包含用户ISA和syscall</li></ul></li><li>API <ul><li>不同用户态库提供的接口</li><li>包含库接口和用户ISA eg:<code>libc</code></li></ul></li></ul></li><li><p>虚拟机监控器(VMM/Hypervisor)</p><ul><li>向上层虚拟机暴漏其所需的ISA</li><li>可同时运行多台虚拟机(VM)</li><li>需要VMM实现系统ISA的功能：eg：切换内核页表寄存器(TTBR1)</li></ul></li></ul><h2 id="如何实现vmm" tabindex="-1"><a class="header-anchor" href="#如何实现vmm" aria-hidden="true">#</a> 如何实现VMM</h2><ul><li>实现系统ISA<br> 系统ISA设计时仅考虑只有一个人调，不允许多个人执行，要实现让多个人调用系统ISA，当运行系统ISA时，不能由硬件真正运行系统ISA</li></ul><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>捕捉所有系统ISA并陷入(Trap)</li><li>由具体指令实现相应虚拟化 <ul><li>控制虚拟处理器行为</li><li>控制虚拟内存行为</li><li>控制设备行为</li></ul></li><li>回到虚拟机继续执行</li></ol><h2 id="cpu虚拟化" tabindex="-1"><a class="header-anchor" href="#cpu虚拟化" aria-hidden="true">#</a> CPU虚拟化</h2><figure><img src="'+T+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>将VMM运行在EL1</li><li>将guest操作系统和其进程运行在EL0</li><li>当操作系统执行ISA指令时Trap进入EL1的VMM由VMM模拟实现</li><li><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul><p>x86和arm有些指令不能虚拟化(在EL0和EL1下执行效果不一样),在用户态执行被当作<code>NOP</code>指令，不会产生Trap</p><h3 id="如何处理不会产生trap的系统指令" tabindex="-1"><a class="header-anchor" href="#如何处理不会产生trap的系统指令" aria-hidden="true">#</a> 如何处理不会产生Trap的系统指令</h3><ol><li>解释执行</li><li>二级制翻译</li><li>半虚拟化</li><li>硬件虚拟化(修改硬件)</li></ol><h4 id="_1-解释执行" tabindex="-1"><a class="header-anchor" href="#_1-解释执行" aria-hidden="true">#</a> 1.解释执行</h4><ul><li>用软件对所有的虚拟机代码模拟执行 <ul><li>不区分是否敏感指令</li><li>没有虚拟机指令直接在硬件上执行</li></ul></li><li>在内存中维护虚拟机的状态<br><img src="'+x+'" alt="" loading="lazy"></li></ul><p>pros</p><ul><li>解决了敏感函数不Trap问题</li><li>可以模拟不同ISA的虚拟机</li><li>实现简单</li></ul><p>cons</p><ul><li>执行速度慢，一条指令会被模拟为多条指令</li></ul><h4 id="_2-二级制翻译" tabindex="-1"><a class="header-anchor" href="#_2-二级制翻译" aria-hidden="true">#</a> 2.二级制翻译</h4><ul><li>提出两个加速技术 <ul><li>执行前<strong>批量翻译</strong>虚拟机指令</li><li><strong>缓存</strong>已经翻译的指令</li></ul></li><li>使用基本块(Basic Block)为翻译粒度<br><img src="'+Q+'" alt="" loading="lazy"></li></ul><p>cons:</p><ul><li>不能处理自修改的代码(eg:jvm)</li><li>中断插入粒度变大 <ul><li>模拟执行可在任意指令位置插入中毒</li><li>二进制翻译只能在Basic Block边界插入中断(执行Basic Block时VMM没有介入)</li></ul></li></ul><h4 id="_3-半虚拟化" tabindex="-1"><a class="header-anchor" href="#_3-半虚拟化" aria-hidden="true">#</a> 3.半虚拟化</h4><ul><li>让VMM提供接口给虚拟机，称为<strong>Hypercall</strong></li><li>修改guest操作系统源码，将敏感指令替换为<strong>Hypercall</strong></li></ul><p>cons</p><ul><li>需要修改操作系统源码</li></ul><h4 id="_4-硬件虚拟化" tabindex="-1"><a class="header-anchor" href="#_4-硬件虚拟化" aria-hidden="true">#</a> 4.硬件虚拟化</h4><ul><li><p>x86和arm引入了虚拟化特权级</p></li><li><p>x86引入了<strong>root mode</strong>和<strong>non-root mode</strong></p><ul><li>intel 推出了VT-x硬件虚拟化扩展</li><li><strong>root mode</strong>是最高特权级，控制物理资源</li><li>VMM运行在<strong>root mode</strong>,虚拟机运行在<strong>non-root mode</strong></li><li>两个mode内都有4个特权级：ring0-ring3</li></ul></li><li><p>arm引入了EL2</p><ul><li>VMM运行在EL2</li><li>EL2是最高特权级，控制物理资源</li><li>VMM的操作系统和应用程序分别运行在EL1和EL0</li></ul></li></ul><h4 id="vt-x" tabindex="-1"><a class="header-anchor" href="#vt-x" aria-hidden="true">#</a> VT-x</h4><figure><img src="'+M+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="virtual-machine-control-structure-vmcs" tabindex="-1"><a class="header-anchor" href="#virtual-machine-control-structure-vmcs" aria-hidden="true">#</a> Virtual Machine Control Structure(VMCS)</h5><ul><li><p>VMM提供给硬件的内存页(4KB)</p><ul><li>记录当前VM的运行状态</li></ul></li><li><p>VM Entry</p><ul><li>硬件自动将当前CPU中的VMM状态保存到VMCS</li><li>硬件自动从VMCS中加载VM状态到CPU</li></ul></li><li><p>VM　Exit</p><ul><li>硬件自动将当前CPU中的VM状态保存到VMCS</li><li>硬件自动从VMCS中加载VMM状态到CPU</li></ul></li><li><p>包含6个部分</p><ul><li>Guest-state area:发生VM exit时，CPU的状态会被硬件自动保存至该区域;发生VM Entry时，硬件自动从该区域加载状态至CPU中</li><li>Host-state area:发生VM exit时，硬件自动从该区域加载状态至CPU中;发生VM Entry时，CPU的状态会被自动保存至该区域</li><li>VM-execution control fields :控制Non-root模式中虚拟机的行为</li><li>VM-exit control fields :控制VM exit的行为</li><li>VM-entry control fields :控制VM entry的行为</li><li>VM-exit information fields : VM Exit的原因和相关信息（只读区域)</li></ul></li></ul><ol><li>VMXON 开启VT-x</li><li>VMLAUNCH 进入虚拟机(加载虚拟机的状态)</li><li>当遇到满足VMEXIT指令 -&gt; VMM ring0, VMM执行该指令</li><li>VMRESUME 回到虚拟机</li></ol><p><strong>x86修改CPU为了给VM一个新环境，arm修改虚拟机为了给VMM一个新环境</strong></p><h4 id="arm虚拟化" tabindex="-1"><a class="header-anchor" href="#arm虚拟化" aria-hidden="true">#</a> ARM虚拟化</h4><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>VM Entry</p><ul><li>使用ERET指令从VMM进入VM</li><li>进入VM之前VMM需要主动加载VM的运行状态(各种寄存器)</li></ul></li><li><p>VM Exit</p><ul><li>虚拟机执行敏感指令或收到中断</li><li>以Exception、IRQ、FIQ形式回到VMM</li><li>VMM主动保存VM的状态</li></ul></li><li><p>VM Exit时VMM可以访问VM的EL0和EL1寄存器</p></li></ul><h3 id="vm和vcpu" tabindex="-1"><a class="header-anchor" href="#vm和vcpu" aria-hidden="true">#</a> VM和VCPU</h3><ul><li><p>VM</p><ul><li>静态部分：内存，设备等</li><li>动态部分：VCPU</li></ul></li><li><p>VCPU</p><ul><li>用线程模拟CPU</li><li>虚拟寄存器 <ul><li>PC</li><li>通用寄存器</li><li>...</li></ul></li><li>切换VCPU时切换到其虚拟寄存器</li></ul></li></ul><h3 id="qemu-kvm" tabindex="-1"><a class="header-anchor" href="#qemu-kvm" aria-hidden="true">#</a> QEMU/KVM</h3><ul><li><p>qemu运行在用户态，实现策略</p><ul><li>也提供虚拟设备支持</li></ul></li><li><p>KVM以linux内核模块运行，实现机制</p><ul><li>可以直接使用linux的功能(内存管理，进程调度)</li><li>使用硬件虚拟化功能</li></ul></li><li><p>KVM捕捉所有敏感指令和事件，传递给QEMU</p></li><li><p>KVM不提供设备虚拟化，需要使用QEMU的虚拟设备</p></li><li><p>1个虚拟机对应1个QEMU进程</p></li><li><p>VM的VCPU对应QEMU的线程</p></li><li><p>QEMU使用<code>/dev/kvm</code>与内核态的KVM通信</p><ul><li>使用ioctl向KVM传递命令：<code>CREATE_VM</code>,<code>CREATE_VCPU</code>,<code>KVM_RUN</code>...</li><li>创建虚拟机所需的运行环境(memory,VCPU,...)后调用<code>KVM_RUN</code>进入<strong>non-root mode</strong>执行<br><img src="'+V+`" alt="" loading="lazy"></li></ul></li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kvm.h&gt;</span></span>

  <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;/dev/kvm&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>KVM_CREATE_VM<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>KVM_CREATE_VCPU<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>KVM_RUN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入内核 -&gt; 返回到VM</span>
    <span class="token comment">// VM执行到敏感指令 -&gt; trap kernel -&gt; KVM [-&gt; qemu]</span>
    reason <span class="token operator">=</span> <span class="token function">get_exit_reason</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="ioctl-fd-kvm-run" tabindex="-1"><a class="header-anchor" href="#ioctl-fd-kvm-run" aria-hidden="true">#</a> ioctl(fd,KVM_RUN)</h4><ul><li><p>ARM</p><ul><li>KVM主动加载VCPU的所有状态</li><li>使用<code>eret</code>进入VM</li></ul></li><li><p>x86</p><ul><li>KVM找到VCPU对应的VMCS</li><li>使用指令加载VMCS</li><li><code>VMLAUNCH</code>/<code>VMRESUME</code>进入<strong>non-root node</strong><ul><li>硬件自动同步状态</li><li>PC = VMCS-&gt;GUEST_RIP</li></ul></li></ul></li></ul><h4 id="io处理流程" tabindex="-1"><a class="header-anchor" href="#io处理流程" aria-hidden="true">#</a> IO处理流程</h4><figure><img src="`+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="内存虚拟化" tabindex="-1"><a class="header-anchor" href="#内存虚拟化" aria-hidden="true">#</a> 内存虚拟化</h2><ul><li><p>为虚拟机提供虚拟的物理地址空间</p></li><li><p>三种地址</p><ul><li>Guest Virtual Address(GVA) <ul><li>虚拟机内进程使用的虚拟地址</li></ul></li><li>Guest Physical Address(GPA) <ul><li>虚拟机内使用的假物理地址</li></ul></li><li>Host Physical Address(HPA) <ul><li>真实的物理地址</li><li>GPA需要翻译为HPA</li></ul></li></ul></li><li><p>实现内存虚拟化</p><ul><li>影子页表(Shadow Page Table):为每个进程提供一个<code>GVA-&gt;HPA</code>的页表</li><li>直接页表(Direct Page Table):告诉VM运行在虚拟机中</li><li>硬件虚拟化</li></ul></li></ul><h3 id="硬件虚拟化" tabindex="-1"><a class="header-anchor" href="#硬件虚拟化" aria-hidden="true">#</a> 硬件虚拟化</h3><ul><li>Intel Extended Page Table(EPT)</li><li>ARM Stage-2 Page Table(第二阶段页表)</li><li>新页表 <ul><li>将GPA翻译为HPA</li><li>被VMM控制</li><li>每个VM有一个对应页表</li></ul></li></ul><h4 id="翻译过程" tabindex="-1"><a class="header-anchor" href="#翻译过程" aria-hidden="true">#</a> 翻译过程</h4><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>Guest Page Table 中保存 GPA</li><li>Host Page Table 中保存 HPA</li><li>共24次访存</li></ul><h4 id="tlb刷新-1" tabindex="-1"><a class="header-anchor" href="#tlb刷新-1" aria-hidden="true">#</a> TLB刷新</h4><ul><li>刷TLB相关指令 <ul><li>清空全部 <code>TLBI VMALLS12E1IS</code></li><li>清空指定GVA <code>TLBI VAE1IS</code></li><li>情况指定GPA <code>TLBI IPAS2E1IS</code></li></ul></li></ul><h4 id="如何处理缺页异常" tabindex="-1"><a class="header-anchor" href="#如何处理缺页异常" aria-hidden="true">#</a> 如何处理缺页异常</h4><ul><li>第一阶段缺页异常 <ul><li>调用VM的Page fault handler</li><li>不会引起VM <strong>Trap</strong></li></ul></li><li>第二阶段缺页异常 <ul><li>VM Trap，直接调用VMM的Page fault handler</li></ul></li></ul><p>pros：</p><ul><li>不需要捕捉Guest Page Table的更新</li><li>减少内存开销：每个VM对应一个页表</li></ul><p>cons：</p><ul><li>TLB miss时性能开销大</li></ul><h2 id="io虚拟化" tabindex="-1"><a class="header-anchor" href="#io虚拟化" aria-hidden="true">#</a> IO虚拟化</h2><ul><li>为VM提供虚拟设备</li><li>隔离不同VM对设备的访问</li><li>提高物理设备的利用率</li></ul><h3 id="如何实现io虚拟化" tabindex="-1"><a class="header-anchor" href="#如何实现io虚拟化" aria-hidden="true">#</a> 如何实现IO虚拟化</h3><ul><li>设备模拟</li><li>半虚拟化</li><li>设备直通</li></ul><h4 id="设备模拟" tabindex="-1"><a class="header-anchor" href="#设备模拟" aria-hidden="true">#</a> 设备模拟</h4><ul><li><p>OS与设备交互的接口</p><ul><li>模拟寄存器(中断)</li><li>捕捉MMIO,PIO指令</li></ul></li><li><p>软件模拟方式</p><ul><li>将PIO指令替换为系统调用</li><li>MMIO对应内存的第二阶段页表设为invalid(Trap)</li></ul></li><li><p>硬件虚拟化方式</p><ul><li>硬件捕捉PIO指令</li><li>MMIO对应内存的第二阶段页表设为invalid</li></ul></li></ul><p><img src="'+C+'" alt="" loading="lazy"><br><img src="'+A+'" alt="" loading="lazy"></p><h4 id="半虚拟化" tabindex="-1"><a class="header-anchor" href="#半虚拟化" aria-hidden="true">#</a> 半虚拟化</h4><ul><li>VM知道自己运行在虚拟环境</li><li>VM运行<strong>front-end</strong></li><li>VMM运行<strong>back-end</strong></li><li>VMM给VM提供<strong>Hypercall</strong></li><li>通过共享内存传递指令和数据</li></ul><figure><img src="'+P+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>back-end</strong>可以在内核中实现</li></ul><figure><img src="'+S+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>pros:</p><ul><li>多个MMIO/PIO指令可以整合为一次Hypercall</li></ul><p>cons:</p><ul><li>需要修改操作系统内核</li></ul><h4 id="设备直通" tabindex="-1"><a class="header-anchor" href="#设备直通" aria-hidden="true">#</a> 设备直通</h4><ul><li>由于网卡直接访问<strong>HPA</strong>,可能造成恶意读写</li><li>让网卡访问<strong>GPA</strong>,VM只能访问自己的内存</li></ul><p><strong>增加IOMMU</strong></p><figure><img src="'+I+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+E+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>设备独占问题</strong></p><ul><li>single root i/o virtualization <ul><li><p>在物理层实现设备虚拟化</p></li><li><p>能够创建多个Virtual Function(VF),每个VM分配一个VF</p></li><li><p>物理设备称为Physical Function(PF),由Host管理</p></li><li><p>需要特定硬件(IOMMU等)支持</p></li></ul></li></ul><h2 id="中断虚拟化" tabindex="-1"><a class="header-anchor" href="#中断虚拟化" aria-hidden="true">#</a> 中断虚拟化</h2><ul><li>VMM完成IO操作(DMA)后通知VM</li><li>VMM在<code>VM ENTRY</code>时插入中断</li></ul><h3 id="virtual-cpu-interface" tabindex="-1"><a class="header-anchor" href="#virtual-cpu-interface" aria-hidden="true">#</a> virtual CPU interface</h3><ul><li><p>GIC为VM提供硬件功能</p><ul><li>VM通过virtual CPU interface与GIC交互</li><li>VMM通过physical CPU interface与GIC交互</li></ul></li><li><p>插入中断</p></li><li><p>通过<strong>GIC List Register</strong>插入中断号</p></li></ul><figure><img src="'+H+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>v4中，VMM需要通知GIC当前的调度信息，GIC才能将中断插入正确的CPU</li></ul><h2 id="轻量级虚拟化" tabindex="-1"><a class="header-anchor" href="#轻量级虚拟化" aria-hidden="true">#</a> 轻量级虚拟化</h2><h3 id="fass-function-as-a-service-and-serverless" tabindex="-1"><a class="header-anchor" href="#fass-function-as-a-service-and-serverless" aria-hidden="true">#</a> Fass(Function as a service) and Serverless</h3><ul><li><p>现有方案：虚拟机</p><ul><li>Function执行时创建虚拟机</li><li>Function执行完销毁虚拟机</li></ul></li><li><p>过于重量级，启动延时高</p></li><li><p>不用虚拟化方案</p><ul><li>window server允许多个用户同时访问远程桌面</li><li>缺点：缺少文件隔离</li></ul></li></ul><p><strong>chroot</strong></p><ul><li>为每个执行环境提供独立的文件系统视图</li><li>改变进程的根目录</li></ul><p>简单实现</p><ul><li>内核为每个用户保存其根目录</li><li>注意检查<code>../</code></li></ul><h3 id="基于namespace的限制" tabindex="-1"><a class="header-anchor" href="#基于namespace的限制" aria-hidden="true">#</a> 基于namespace的限制</h3><ul><li><p>通过文件系统的namespace限制用户</p></li><li><p>可以在其他层(inode number)限制用户</p></li></ul><p>问题</p><ul><li>如何共享部分文件(<code>ls</code>)</li></ul><h2 id="linux容器" tabindex="-1"><a class="header-anchor" href="#linux容器" aria-hidden="true">#</a> linux容器</h2><ul><li>由linux内核提供资源隔离</li><li>安全隔离：<code>linux namespace</code></li><li>性能隔离：<code>linux cgroup</code></li></ul><h3 id="linux-namespace" tabindex="-1"><a class="header-anchor" href="#linux-namespace" aria-hidden="true">#</a> linux namespace</h3><ul><li>每种<strong>linux namespace</strong>封装一种全局资源</li></ul><ol><li>mount namespace</li></ol><ul><li><p>在内核分别记录每个NS对于挂载点的修改</p></li><li><p>访问挂载点时，根据当前NS的记录访问文件</p></li><li><p>每个NS有独立的NS文件系统树</p></li><li><p>修改挂载点只会修改自己的NS树</p></li><li><p>实现了文件的共享</p></li></ul><ol start="2"><li>IPC namespace</li></ol><ul><li>每个IPC对象只能属于一个NS</li><li>进程只能在当前NS中寻找IPC对象</li></ul><ol start="3"><li>network namespace</li></ol><p>linux 对多IP的支持</p><ul><li>内核中创建一个虚拟交换机</li><li>VM的网卡连接到交换机上</li></ul><p>Linux namespace</p><ul><li><p>每个NS拥有一套独立的网络资源(ip,网络设备)</p></li><li><p>新的NS默认仅有loopback设备</p></li><li><p>NS中的网卡连接到虚拟交换机上</p></li><li><p>通过ARP协议将多个ip与物理网卡MAC地址绑定，实现收多个ip的数据包</p></li></ul><ol start="4"><li>PID namespace</li></ol><ul><li>每个namespace只能看到自己namespace得到PID</li><li>parent NS可以看到child NS的PID，反之不行</li><li>子NS中进程在父NS中也有PID</li><li>子NS中进程无法向外部发送信号</li></ul><ol start="5"><li>user namespace</li></ol><ul><li>隔离用户权限</li><li>对NS内外UID和GID映射</li><li>每个NS都有UID为0的root用户，映射为外部的其他UID，在NS外部无root权限</li></ul><ol start="6"><li>UTS namespace</li></ol><ul><li>每个NS拥有自己的hostname</li></ul><ol start="7"><li>Cgroup(control group) namespace</li></ol><ul><li>实现资源隔离</li><li>将线程分组，对每组线程多种物理资源监控</li></ul><h1 id="网络协议栈" tabindex="-1"><a class="header-anchor" href="#网络协议栈" aria-hidden="true">#</a> 网络协议栈</h1><h2 id="linux收包过程" tabindex="-1"><a class="header-anchor" href="#linux收包过程" aria-hidden="true">#</a> linux收包过程</h2><figure><img src="'+L+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>DMA将数据传送到内核RX缓冲区</li><li>触发中断</li><li>cpu收到中断,触发中断处理程序(上半部)</li></ol><ul><li>分配<code>sk_buff</code>数据结构，将数据帧copy到接收队列</li><li>发出<strong>NET_RX_SOFTIRQ</strong>软中断，通知内核接收到数据帧</li></ul><ol start="4"><li>内核在合适的时机(返回用户态之前)检查softirq队列并处理软中断(进入下半部)</li><li>将接收队列的数据帧copy到<code>sk_buff</code>缓冲区中</li><li>根据数据包的类型，调用对应的协议处理函数</li></ol><ul><li>TCP会将数据copy到socket的<strong>Recv-Q</strong>,唤醒等待在socket上的线程</li><li>用户调用<code>recv(buff)</code>将数据copy到用户态</li></ul><h1 id="操作系统调试" tabindex="-1"><a class="header-anchor" href="#操作系统调试" aria-hidden="true">#</a> 操作系统调试</h1><ul><li>中断程序运行读取内部状态</li><li>获取程序异常退出原因</li><li>动态修改程序状态</li><li>控制追踪流</li></ul><h2 id="linux调试支持-ptrace系统调用" tabindex="-1"><a class="header-anchor" href="#linux调试支持-ptrace系统调用" aria-hidden="true">#</a> linux调试支持：ptrace系统调用</h2><ol><li>子进程通过<code>PTRACE_TRACEME</code>将调试权交给父进程，父进程可以读取，修改子进程的状态</li><li>通过<code>PTRACE_ATTACH</code>调试指定进程</li></ol><p><strong>GDB捕捉异常信号</strong></p><p>GDB等待子进程事件，子进程发生时间后会通知父进程</p><ul><li><code>PTRACE_GETSIGINFO</code>获取被调试进程signal</li><li><code>PTRACE_GETREGS</code>获取被调试进程的RIP</li></ul><p><strong>断点</strong></p><ul><li><p>断点异常指令</p><ul><li>在执行到特定指令时，触发断点异常陷入内核</li><li>x86: <code>int 3</code>, AARCH64: <code>BKP</code></li></ul></li><li><p>单步调试</p><ul><li>在用户态执行一条指令后立即陷入内核</li><li>x86 Trap flag</li></ul></li></ul><ol><li><code>PTRACE_POKETEXT</code>修改进程代码为断点指令</li><li>子进程执行到断点，触发断点异常，产生<code>SIGTRAP</code>signal并通知GDB</li></ol><p><strong>内存断点</strong></p><ul><li><p>基本实现</p><ul><li>将内存地址所在页设为只读</li><li>访问时触发page fault</li><li>对该页所有的写操作均导致page fault</li></ul></li><li><p>断点寄存器</p><ul><li>当访存地址为寄存器中的值时，触发断点异常</li></ul></li></ul><p><strong>远程调试</strong></p><figure><img src="'+R+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>GDB客户端负责指令发送</p><ul><li>GDB远端串行协议(GDB remote serial protocol,RSP)</li></ul></li><li><p>GDB stub 控制调试应用</p></li></ul><h2 id="性能调试" tabindex="-1"><a class="header-anchor" href="#性能调试" aria-hidden="true">#</a> 性能调试</h2><h3 id="确定内核执行中耗时较长的函数" tabindex="-1"><a class="header-anchor" href="#确定内核执行中耗时较长的函数" aria-hidden="true">#</a> 确定内核执行中耗时较长的函数</h3><p><strong>硬件计数器</strong></p><ul><li><p>监控程序执行过程中处理器发生某些事件的次数</p><ul><li>e.g., 执行指令数量，缓存失效次数</li></ul></li><li><p>方法1：获取事件发生次数</p><ul><li>设置事件类型，打开计数器</li><li>一段时间后读取计数器</li><li>缺点：可能涉及对源代码修改(插桩)</li></ul></li><li><p>方法2：采样</p><ul><li>设置事件类型，打开计数器</li><li>当计数器溢出时，产生中断 <ul><li>在中断处理中获取地址信息</li><li>清空计数器，等待下一次中断</li></ul></li><li>每经过一定cycle触发一次中断，统计中断时指令地址，获取这些地址属于哪些函数</li></ul></li></ul><h4 id="linux-性能计数器采样支持" tabindex="-1"><a class="header-anchor" href="#linux-性能计数器采样支持" aria-hidden="true">#</a> linux 性能计数器采样支持</h4><ul><li><p>性能相关事件 perf events</p><ul><li>以event的抽象暴露性能计数器</li><li>perf_event_open通知内核需要使用哪些计数器</li><li>采样过程有内核完成</li><li>采样结果放入内核与用户共享内存中</li></ul></li><li><p>前端工具perf</p><ul><li>perf工具包包装常见的性能分析方法</li><li><code>perf record -e cycles &lt;app&gt;</code></li><li><code>perf report</code></li></ul></li></ul><h4 id="基于中断采样的缺点" tabindex="-1"><a class="header-anchor" href="#基于中断采样的缺点" aria-hidden="true">#</a> 基于中断采样的缺点</h4><ul><li>采样获取的指令地址不准确 <ul><li>中断发送需要时间，CPU收到中断时的指令地址可能有偏移</li><li>乱序执行</li></ul></li></ul><h3 id="控制流追踪" tabindex="-1"><a class="header-anchor" href="#控制流追踪" aria-hidden="true">#</a> 控制流追踪</h3><ul><li><p>软件方法backtrace追踪</p><ul><li>问题：编译器优化去除栈帧</li></ul></li><li><p>硬件的控制流追踪</p><ul><li><p>记录jmp、call、中断导致跳转的前后位置</p></li><li><p>e.g.Last Branch Record(intel)</p><ul><li>两组寄存器分别构成栈，记录最近N次跳转信息</li></ul></li><li><p><code>perf record -e cycles -g &lt;app&gt;</code></p></li><li><p><code>perf report</code></p></li></ul></li></ul><h3 id="静态追踪方法" tabindex="-1"><a class="header-anchor" href="#静态追踪方法" aria-hidden="true">#</a> 静态追踪方法</h3><ul><li><p>在代码编写时插桩</p><ul><li>打印</li></ul></li><li><p>预置静态追踪函数</p><ul><li>e.g.,linux Tracepoint</li></ul></li><li><p>缺点</p><ul><li>修改跟踪点需要重新编译</li><li>有些函数没有tracepoint</li></ul></li></ul><h3 id="动态追踪方法" tabindex="-1"><a class="header-anchor" href="#动态追踪方法" aria-hidden="true">#</a> 动态追踪方法</h3><ul><li>程序运行时，在不确定的代码位置插入一段动态指定的追踪函数</li><li>e.g.,linux kprobe，类似于断点调试</li></ul><ol><li>使用断点指令替换原指令</li><li>执行时产生异常</li><li>调用handler</li><li>恢复原指令，单步调试</li><li>重新设置断点指令，返回继续执行</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">ssize_t</span> <span class="token function">vfs_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span><span class="token operator">*</span> file<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span><span class="token class-name">size_t</span> count<span class="token punctuation">,</span><span class="token class-name">loff_t</span><span class="token operator">*</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>检查count的大小<br><code>perf probe --add &#39;vfs_read count=%dx:u64&#39;</code></li></ul>`,212);function sa(la,ia){return s(),l("div",null,[B,a("mjx-container",N,[(s(),l("svg",G,z)),O]),a("blockquote",null,[a("p",null,[a("mjx-container",Z,[(s(),l("svg",F,j)),q]),i("可并行部分所占比例"),W,a("mjx-container",X,[(s(),l("svg",J,$)),aa]),i("并行核心数")])]),na])}const oa=e(U,[["render",sa],["__file","os.html.vue"]]);export{oa as default};
