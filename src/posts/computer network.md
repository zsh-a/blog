---
title: network
tag: [network]
---

# tcp

## 拥塞控制
- 最大化时延带宽积
  - $时延带宽积=链路带宽\times 往返时延$
- 如何估计该数值?
### cubic
- 不断增加发送窗口，直到出现丢包
  - 加性增，乘性减
- 不能区分**拥塞丢包**和**错误丢包**
- 错误丢包率需要与发送窗口的平方成反比才能正常工作
  - 估计值偏小，不能占满资源

- bufferbloat（缓冲区膨胀）
  - 网络中节点存在buffer
  - 估计值偏大
  - 增加网络延迟
  - 缓冲区被填满而丢包

### BBR
- 不考虑丢包
- 分别估计带宽和时延
  - 无法同时测准

- 交替测量带宽和延迟
  - 用一段时间内的带宽极大值和延迟极小值作为估计值

1. 慢启动
   - 指数增长发送速率，将通道占满
   - 如果网络中有buffer，把缓冲区填满才会放弃
2. 排空（drain）
   - 指数降低发送速率，buffer中的包会被慢慢排空，直到往返延迟不再降低

- 充分利用带宽，适合高延迟、高带宽的链路
- 降低buffer的占用率，从而降低延迟

# QUIC
## 动机
- TCP需要至少一个rtt握手，tls添加了两个rtt
- 队头阻塞时延
- 重传模糊
  - 重传的tcp段有相同的序列号
  - 接收到的ACK不能区分原始包和重传包
  - 采样RTT不准确
  - 通过昂贵的timeout检测重传丢失

## 设计
### 连接建立
- 当成功握手之后，client缓存**origin**信息
- 接下来的连接相同的origin，client能够无需rtt建立加密连接
  - 数据可以立即发送无需等待server回复
  - 0-rtt 握手
- 使用Diffie-Hellman密钥交换算法

### 初始握手
0. server配置长期密钥对config（p,g,K_pub）
1. client发送hello到server
2. server回复config
3. client收到后生成随机数并计算公钥和对称密钥
4. client将公钥和加密数据发送给server
5. server收到后计算对称密钥
6. 双方通过各自的额外公钥计算前向安全的通信密钥

### 再次连接
- client已经缓存了config，直接从step.3 开始
- 一次一密

### 流复用
- 一个连接可以存在多个流，一个udp包丢失仅会影响该包中的流
- stream IDs标识
- 